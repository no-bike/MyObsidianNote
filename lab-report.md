



# 哈尔滨工业大学CS33503数据库系统实验报告

姓名：曲本磊

学号：2022112479

班级：2203501

专业：数据科学与大数据技术

学期：2024春

## 声明

本人承诺该实验全部由本人独立完成，没有抄袭他人代码。若被证实本人存在抄袭现象或为他人抄袭提供帮助，本人愿意承担全部责任（包括但不限于扣分、取消考试资格、上报学部等）。

## 目录

[TOC]

## 实验1：存储管理实验

### 任务1.1：磁盘存储管理器

在这一部分，你需要列举并介绍你实现的全部方法。你需要按照方法所在的类进行组织。在介绍每个方法的具体实现时，需要包含以下内容：

1. 方法的声明。给出方法的声明（注意：是方法声明，不是方法定义）。如果这个方法是你自己声明的，请说明它的功能以及为何要声明这个方法，何时调用这个方法。
2. 方法实现思路。根据方法实现的难度，可以采用不同的介绍形式。对于简单的方法，简要介绍方法的实现思路即可。对于复杂的方法，如果执行过程非常复杂，可以借助流程图或伪代码进行介绍。
3. 方法实现难点。如果你在实现这个方法的过程中遇到了较大的困难，不妨介绍一下你遇到的是什么困难，你最终的解决办法是什么。

#### DiskManager类的实现

```c++
void DiskManager::write_page(int fd, page_id_t page_no, const char *offset, int num_bytes);
```
将页面写入到磁盘中，需要使用lseek()函数定位文件头，利用句柄fd和偏离量。再通过write（）函数写入。

注意错误类型要选择正确。

```c++
void DiskManager::read_page(int fd, page_id_t page_no, char *offset, int num_bytes);
```
将页面写入到磁盘中，需要使用lseek()函数定位文件头，利用句柄fd和偏离量。再通过read（）函数写入。

注意错误类型要选择正确。

```c++
void DiskManager::create_file(const std::string &path) ;
```
这段C++代码是用来打开或创建一个文件的。它使用了`open`函数，这是一个在POSIX兼容的操作系统（如Linux和macOS）中常用的系统调用，用于打开和可能创建一个文件。

`open`函数的第一个参数是文件的路径，这里通过`path.c_str()`获取，其中`path`是一个`std::string`类型的变量，表示文件的路径。`c_str()`函数用于获取`std::string`的C风格字符串表示，因为`open`函数需要一个C风格的字符串作为路径参数。

第二个参数是一个位掩码，用于指定文件的打开方式和行为。在这个实现中，使用了`O_CREAT`和`O_WRONLY`两个选项的按位或（`|`）组合。`O_CREAT`表示如果指定的文件不存在，则创建它；`O_WRONLY`表示文件将以只写模式打开。这意味着如果文件已经存在，这段代码将打开它以便写入；如果文件不存在，将创建一个新文件，然后以只写模式打开。

```c++
void DiskManager::destroy_file(const std::string &path);
```

使用unlink函数来删除文件，但需要注意的是，如果指定的文件不存在，或者调用进程没有足够的权限来删除该文件，unlink函数将失败，并返回`-1`。成功执行时，它会返回`0`。
。
```c++
int DiskManager::open_file(const std::string &path);
```

这段代码是一个C++项目中的一部分，用于管理磁盘上的文件。具体来说，它定义了一个名为DiskManager的类，该类中的open_file方法用于打开一个指定路径的文件。这个方法首先检查给定路径的文件是否存在，然后检查该文件是否已经被打开，最后如果文件未打开，它会尝试打开文件，并更新内部的文件描述符映射。

首先，open_file方法接收一个std::string，表示要打开文件的路径。方法内部首先调用is_file(函数来检查路径指向的文件是否存在。is_file函数使用stat宏来判断路径是否指向一个常规文件。如果文件不存在，open_file方法会抛出一个FileNotFoundError异常，并返回`-1`。

接下来，open_file方法检查path2fd_（一个从文件路径到文件描述符的映射）中是否已经包含了给定的路径，以判断文件是否已经被打开。如果文件已经打开，方法会抛出一个InternalError异常，并返回`-1`。

如果文件未打开，open_file方法会使用open系统调用尝试以读写模式（O_RDWR）打开文件。[`open`](vscode-file://vscode-app/d:/vs%E9%85%8D%E7%BD%AE/Microsoft%20VS%20Code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html "../../../../../usr/include/x86_64-linux-gnu/bits/fcntl2.h")函数的第一个参数是文件路径的C风格字符串表示，可以通过std::string的c_str方法获得。成功打开文件后，open函数会返回一个文件描述符，这是一个非负整数，用于标识打开的文件。

最后，open_file方法会更新两个映射：path2fd_和fd2path_。path2fd_映射用于记录文件路径到文件描述符的映射，而fd2path_映射则记录文件描述符到文件路径的映射。这样做可以方便地通过文件路径或文件描述符查找对应的另一项。方法最终返回打开的文件的文件描述符。

```c++
void DiskManager::close_file(int fd);
```

将path2fd_和fd2path_两个映射里该文件删除，再使用close。


#### 实验发现

基础linux磁盘操作。


### 任务1.2：缓冲池替换策略

#### LRUReplacer类的实现

在每个函数内部，首先使用了C++17的`std::scoped_lock`来自动管理互斥锁latch_。`std::scoped_lock`是一个作用域锁，它在构造时自动上锁，并在析构时自动解锁，从而避免了死锁的发生并保证了线程安全。

```c++
bool LRUReplacer::victim(frame_id_t* frame_id);
```

这段代码是实现最近最少使用（LRU）替换策略的一部分，用于在缓存管理中选择一个页面进行淘汰。LRU策略的核心思想是淘汰最长时间未被访问的页面，因为这样的页面在未来被访问的可能性较小。

首先，LRUReplacer::victim()函数接收一个指向frame_id_t类型的指针frame_id作为参数，该函数的目的是找到并返回一个被淘汰的页面的标识符。

接下来，函数检查当前是否有可以被淘汰的页面，这是通过调用Size()函数来完成的，该函数返回LRUlist_的大小，即当前缓存中页面的数量。如果Size()大于0，表示有页面可以被淘汰。

如果有可被淘汰的页面，代码首先从LRUlist_中获取最后一个元素，即最久未被访问的页面，然后从LRUhash_中移除该页面。LRUlist_是一个双向链表，用于按访问顺序存储页面，而LRUhash_是一个哈希表，用于快速查找页面是否存在于缓存中。最后，将被淘汰的页面的标识符赋值给`*frame_id`，并返回`true`表示成功找到并淘汰了一个页面。

如果没有可被淘汰的页面，即LRUlist_为空，函数将frame_id设置为`nullptr`并返回`false`，表示没有页面被淘汰。

```c++
void LRUReplacer::pin(frame_id_t frame_id);
```

`pin`函数的目的是将指定的帧（frame）标记为“固定”的，意味着这个帧不应该被替换。

如果函数在未固定列表和哈希表中找到了这个frame_id，则会将其从未固定列表与哈希表中删除。

```c++
void LRUReplacer::unpin(frame_id_t frame_id);
```

如果未固定列表和哈希表中没有该frame_id，则将其添加进去。
#### 实验发现

课上讲的LRU策略，在这一任务中实现。


### 任务1.3：缓冲池管理器

#### BufferPoolManager类的实现

```c++
bool BufferPoolManager::find_victim_page(frame_id_t* frame_id);
```

这段代码是缓冲池管理器（BufferPoolManager）中用于寻找一个可以被替换的页面（victim page）的函数实现。在数据库系统中，缓冲池管理器负责管理内存中页面的缓存，以减少对磁盘的访问次数。当需要加载一个新页面到缓冲池中，但缓冲池已满时，就需要选择一个页面进行替换。

函数`find_victim_page`的主要逻辑分为两部分：

1. **检查空闲列表**：首先，函数检查`free_list_`，这是一个包含空闲帧（frame）的列表。如果这个列表不为空，说明缓冲池中还有空间，不需要替换页面。函数从`free_list_`中取出一个空闲帧的ID，赋值给`frame_id`参数，并从列表中移除该帧ID，然后返回`true`表示已找到一个可用的帧。

2. **使用LRU替换策略选择淘汰页面**：如果`free_list_`为空，表示缓冲池已满，需要淘汰一个页面。这时，函数使用`replacer_`（一个实现了LRU替换策略的对象）的`victim`方法来选择一个被淘汰的帧ID。如果成功找到，函数遍历`page_table_`（一个映射页面ID到帧ID的哈希表）来找到对应的页面ID。找到后，检查该页面是否被修改过（即`is_dirty_`标志为`true`），如果是，则将页面的内容写回磁盘。最后，从`page_table_`中移除该页面的条目，并返回`true`表示成功找到并处理了一个被淘汰的页面。

整个函数的返回值表示是否成功找到一个可以被替换的帧。如果在空闲列表中找到了帧，或者通过LRU替换策略成功选择了一个被淘汰的页面，函数返回`true`；如果两者都没有成功，返回`false`。

这个函数体现了数据库系统中页面替换策略的实现，特别是在缓冲池已满时如何选择一个页面进行替换，以及如何处理被替换页面的数据（比如需要将修改过的数据写回磁盘）。

```c++
void BufferPoolManager::update_page(Page* page, PageId new_page_id, frame_id_t new_frame_id);
```

这段代码是在一个名为`BufferPoolManager`的类中定义的`update_page`函数，其目的是更新缓冲池中的一个页面。在数据库系统中，缓冲池管理器负责管理内存中页面的缓存，以减少对磁盘的访问次数。这个函数处理三个主要任务：

1. **处理脏页**：如果传入的页面（`page`）被标记为脏（即`is_dirty_`为`true`），这意味着页面的内容自从被加载到缓冲池以来已经被修改过。在这种情况下，需要将页面的内容写回磁盘，以确保磁盘上的数据是最新的。这通过调用`disk_manager_`的`write_page`方法完成，之后将页面的`is_dirty_`标志重置为`false`，表示页面现在是干净的。

2. **更新页面表**：页面表（`page_table_`）是一个映射，它将页面ID映射到帧ID。更新页面表涉及两个步骤：首先，将新的页面ID（`new_page_id`）映射到新的帧ID（`new_frame_id`），这通过直接在`page_table_`中插入或更新条目来完成。然后，从页面表中删除旧的页面ID，这通过调用`erase`方法并传入旧页面ID完成。

3. **重置页面数据并更新页面ID**：最后，函数通过调用`disk_manager_`的`read_page`方法，使用新的页面ID从磁盘读取页面内容到`page`的数据区域。这相当于用新页面的内容替换了当前页面的内容。然后，更新`page`的页面ID为新的页面ID。

这个函数的设计考虑到了数据库系统中页面生命周期管理的需要，特别是在页面内容更新或页面替换场景中的处理。通过将脏页写回磁盘、更新页面映射表以及重置页面内容，`update_page`函数确保了缓冲池中的数据与磁盘上的数据保持一致，同时也支持了页面的有效管理和替换策略。

```c++
Page* BufferPoolManager::fetch_page(PageId page_id);
```
这段代码是BufferPoolManager类中的fetch_page函数，它的主要作用是从缓冲池中获取一个指定ID的页面。如果页面已经在缓冲池中，它会直接返回该页面；如果不在，它会尝试找到一个可以被替换的页面（即所谓的victim page），然后从磁盘中读取所需页面的数据到这个被替换的页面中。

首先，函数通过std::scoped_lock创建了一个作用域锁lock，以确保在操作过程中缓冲池的状态不会被其他线程改变，保证了线程安全。

接下来，函数尝试在page_table_中查找是否存在目标页面ID。如果找到，说明目标页面已经在缓冲池中，此时会增加该页面的固定计数（pin_count_），并通过replacer_的pin方法标记该页面为已固定，最后返回该页面的指针。

如果在page_table_中没有找到目标页面，函数会尝试通过find_victim_page方法获取一个可用的帧ID。如果find_victim_page)返回false，说明没有可用的帧，函数返回nullptr.

在成功获取到一个可用的帧后，函数会检查这个帧中当前存储的页面是否为脏页（即is_dirty_为`true`）。如果是脏页，需要先将其写回磁盘，以保证数据的一致性。然后，从page_table_中移除这个页面的记录，并将新页面的ID与帧ID关联起来。

之后，函数通过disk_manager_的read_page方法从磁盘读取目标页面的数据到新页面中，并设置新页面的ID和固定计数（pin_count_)。最后，通过replacer_的pin方法标记新页面为已固定，并返回新页面的指针。

```C++
bool BufferPoolManager::unpin_page(PageId page_id, bool is_dirty);
```

这段代码是C++中的一个方法实现，属于`BufferPoolManager`类。它的主要功能是对缓冲池中的页面进行“解钉”操作。在数据库管理系统中，缓冲池管理器负责在内存和磁盘之间高效地交换数据页。"解钉"（unpin）是指将页面从缓冲池中释放，使其可以被替换出去。这个过程通常在页面不再被访问时进行。

1. **锁定**: 方法首先通过`std::scoped_lock`锁定一个互斥量`latch_`，以确保线程安全。这种锁会在当前作用域结束时自动释放，避免了忘记解锁的风险。

2. **查找页面**: 接下来，方法尝试在`page_table_`中查找给定的`page_id`。如果找不到，说明请求的页面不在缓冲池中，因此方法返回`false`。

3. **处理页面**: 如果页面存在于`page_table_`中，方法会获取对应的帧ID，并通过这个帧ID找到实际的页面对象。然后，检查页面的`pin_count_`（钉住计数）：
   - 如果`pin_count_`已经为0，表示页面已经是解钉状态，直接返回`false`。
   - 如果`pin_count_`大于0，表示页面被钉住，需要将其减一。如果减一后`pin_count_`变为0，表示页面现在可以被替换，此时会调用`replacer_`的`Unpin`方法来更新替换策略。

4. **更新脏页标志**: 最后，根据传入的`is_dirty`参数更新页面的`is_dirty_`标志。如果页面在被访问期间被修改了，`is_dirty`应该为`true`，这样在页面被替换出缓冲池时，系统会知道需要将其写回磁盘。

整个方法通过返回`true`或`false`来指示操作是否成功。这个过程对于数据库的性能至关重要，因为它影响到数据的读写效率以及缓冲池的利用率。

```C++
Page* BufferPoolManager::new_page(PageId* page_id);
```

#### 实验发现

内容

### 任务2.1：记录操作


### 任务2.2 记录迭代器

## 实验2 索引管理器

### 任务1 B+树的查找

### 任务2 B+树的插入

### 任务3 B+树的删除

### 任务4 B+树索引并发控制
