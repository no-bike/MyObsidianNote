### 关系数据结构

#### 基本结构

关系型数据库由==**表**的集合==构成

| 姓名  | 性别  | 年龄  |
| --- | --- | --- |
| a   | 男   | 18  |
| b   | 女   | 19  |
- 关系型数据库使用**唯一数据结构**，==关系==
- 每一行叫做==元组==，表示对象，一个表中不能出现相同的元组
- 每一列叫做==属性==，表示对象的性质
- 能区分不同元组的==属性==叫做==**键（码）**==，键不一定只有一个属性

#### 超键、候选键、主键、外键

- **超键**(superkey)：能区分每一个元组的属性集合
- **候选键**(candidate key)：简化到极致的==能区分每一个元组的属性集合==，候选键是超键，但任意候选键的真子集都不是超键
- **主键**(primary key)：人为选择的某一个候选键。
```
\d <表名>
//可以显示表的结构以及primary key（主键）为哪一个元素,以及用户定义约束条件
```
- **外键**(foreign key)：将==不同表==之间建立关系的键。
![[Pasted image 20240410104657.png]]

#### 约束条件（constraint）
满足下述条件的数据是**基本正确**的

1. 实体完整性约束（一个表中）：
	1. 不允许出现两个具有==相同主键值==的元组
	2. ==主键==中的**属性值不可为空**
	```SQL
	insert into student values(NULL,'男'，NULL);
	//会报error，因为主键中的属性值不可为空
	```
2. 参照完整性约束：
	1. 外键取值必须来自其==参照的属性的值==（必须在其参照表里该属性里有）
	2. 外键可以为空
3. 用户定义完整性约束：
	由用户定义的对某些属性中值的约束
	[[3.SQL#声明用户定义完整性约束]]


### 关系代数

![[Pasted image 20240410111424.png]]
#### 基本的关系代数操作
基于上述三个表展示
关系代数计算器RelaX：
[relational algebra calculator (ihu.gr)](https://nireas.iee.ihu.gr/relax/calc.htm)
##### 选择（selection）：σ (sigma)
```
σ Ssex = 'M' (Student)
//选择Student表中Ssex属性为'M'的元组
σ Ssex = 'M'  and Sdept = 'CS' (Student)
//选择Student表中Ssex属性为'M'并且Sdept属性为'CS'的学生
```
##### 投影（projection): Π（pai）
```
π Sdept (Student)
//不重复的展示Student表中Sdept属性的值的集合
```
##### **并(union):∪**
```
σ Sdept = 'CS' (Student)
∪
σ Sdept = 'Math' (Student)
//将两个查询结果并运算显示，结果去重，并且两个集合要相容
```
##### **差(difference):-**
	R-S即把R集合中的与S集合中元素重复的部分删除
##### **笛卡尔积：×**
```
Student × SC
//将两个表的元组无条件的叉乘拼接在一起，需要进行后续处理不然结果无用
σ Student.Sno = SC.Sno (Student ⨯ SC)
//筛选
```
##### **重命名(rename):ρ**（rho）
```
ρ S (Student)
//将Student表重命名为S
ρ sex←Ssex (Student)
//将Student表中的Ssex属性重命名为sex
//不改变源数据库，只是改变输出
//可以使用重命名对一个表自身进行叉乘以后进行表内二元操作，如下方代码块
```

**综合应用**
```
π S1.Sname,S1.Sage (ρ S1 (Student)) -
π S1.Sname,S1.Sage ( σ S1.Sage > S2.Sage (ρ S1 (Student) ⨯ ρ S2 (Student)))

//略长，一行写不完
//该代码是指选出年龄最小的人并显示他的名字和年龄
//上一句是指所有人及其年龄，下一句是所有年龄不为最小的人及其年龄，通过差运算得到最小年龄的人
//解析下一句：
//先对Student表重命名后进行笛卡尔积运算，以便于对表内元素的二元运算
//再选择叉乘集合表中所有年龄非最小的元组
//通过投影，只显示S1中的name和age属性进行去重，得到所有非最小的人及其年龄
```

#### 派生关系代数操作

##### 内连接
R和S的内连接的结果==只包含R和S中满足连接要求的元组==
 
1.  **θ连接**(xita):
	可以按某一个或两个属性来把两个表连接起来，但是这两个属性两个表都要有。[[2.Relational_Database#约束条件（constraint）]]
	``(R) ⨝ θ (S) = σ θ (R × S)，θ为条件

2. **自然连接**
	R和S中==所有同名属性进行等值比较==，结果中同名属性只留一份
	语法：`(R) ⨝ (S)`,有隐含条件所以不需要写θ

##### 外连接
既==包含内连接==有的元组，又==包含不满足条件的元组==

1. **左外连接**(left outer join)
	将R和S中满足条件θ的元组进行连接，即计算``(R) ⨝ θ (S) 
	对==R中不满足连接条件==的元组，左外连接的结果中也包含该元组，只不过S中的属性为(null)
	语法：``(R) ⟕ θ (S)

2. **右外连接**(right outer join)
	与上面定义类似，但保留==S中的不满足条件的元组==，且对R的属性为(null)
	语法：``(R) ⟖ θ (S)
	
3. **全外连接**(Full outer join)
	与上方定义类似，但所有元组均保留，不具有的属性为(null)
	语法：``(R) ⟗ θ (S)

若θ为空则视为条件为自然连接

#### 扩展关系代数操作

##### **分组操作**（Group-by）: γ（gama）

语法：``γ L;agg (R)``
	L为分组属性列表，属性之间用逗号分隔
	agg为==聚集函数表达式==列表，用逗号分隔，聚集函数表达式形如`sum(Sage)->Sagesum`，即把Sage按L的分组加起来后命名为属性Sagesum。
```
γ Sno,Ssex;sum(Sage)->Sagesum (Student)
```